

```
技术面:技术面主要包括八股+项目+手撕，1个小时左右。

一面：
项目: 1. 项目的性能怎么样? 2.项目中是如何进行jvm调优的? 3. 除了web项目, 还用java做了什么?

八股: 1. TreeMap和HashMap的区别. 2.了解哪些垃圾收集器, 说说G1和CMS的区别. 3.了解多线程吗?

手撕: 金银铜奖排序一面整体还行, 问的基本上都答上来了, 手撕用优先级队列秒了.

二面：
八股:1. spring boot和spring的区别.2. spring boot启动过程都发生了什么.3. spring的依赖注入是怎么实现的?4. 在一个方法中改变了注入对象的属性, 另一个方法调用该属性是否改变? 为什么?5. 类加载机制...

手撕: 输入二叉树的中序遍历, 判断是否为二叉搜索树.二面没问项目全程八股, 问题针对一个点逐层深入
---------------------------------------------------------------------------------------------------

一面：
面试有两个部分，手撕代码和八股（也有一些项目问题）。

八股部分：
1. java的模式有哪些；
2. Arraylist和linkedlist的区别；
3. 单例模式的创建；
手撕代码：合并有序链表；
整个流程大概不到20分钟，没有问项目问题。

二面：
手撕代码：
dfs 遍历二叉树寻找节点值的和等于目标值的路径；
八股部分：
1. 索引失效的情况；
2. Redis的使用场景；
3. Jvm的作用；
4. 垃圾回收器，垃圾回收算法；
---------------------------------------------------------------------------------------------------
技术一面
一面是本部门的人，没有问项目，先问了20分钟八股文，问题大致如下：
==和equals
深浅拷贝
开发中是怎么使用数组和链表的
怎么找到链表的倒数第k个节点(不统计链表长度的前提下)
讲讲选择排序算法，什么是稳定性，选择排序稳定吗
hashmap底层原理
优先级队列了解吗
对nio有了解吗
创建多线程有几种方式
多线程状态
线程同步的方式
sybchronized的实现原理
volatile的作用，什么是可见性和有序性
怎么判断一个对象能否被回收
GC ROOT对象有哪些
垃圾回收有哪些算法
标记清除算法的原理
有jvm调优的经验吗
聚集索引和非聚集索引的区别
MYSQL中有哪些锁
意向锁是干什么的
springboot中怎么开启定时任务，是同步的吗
spring中bean的生命周期，作用域
项目中使用的redis是单机还是集群
用过kafka吗
问的都不难，回答的中规中矩吧，然后开始手撕代码，题目简化后大致就是：
给定数组 a，要求输出这样的数组 b，b[i] 是 a[i] 左边第一个比 a[i] 大的元素，若不存在则 b[i] = -1。

技术二面
二面是其他部门交叉面试，这位面试官没有问八股，全问的项目，问题如下：
说说你项目中的秒杀业务
怎么防止超卖
怎么保证幂等性
怎么做的限流
redis实现分布式锁是怎么实现的
你在项目中哪些地方用到了分布式锁
信号量是干什么的
为什么用docker，好处是什么
你在项目中怎么用的docker
```



数据结构&算法

- 金银铜奖排序一面整体还行, 问的基本上都答上来了, 手撕用优先级队列秒了.
- 输入二叉树的中序遍历, 判断是否为二叉搜索树.二面没问项目全程八股, 问题针对一个点逐层深入
- 给定数组 a，要求输出这样的数组 b，b[i] 是 a[i] 左边第一个比 a[i] 大的元素，若不存在则 b[i] = -1。
- 怎么找到链表的倒数第k个节点(不统计链表长度的前提下)
- 讲讲选择排序算法，什么是稳定性，选择排序稳定吗
- 手撕代码：合并有序链表；
- 优先级队列了解吗



计算机/操作系统/网络协议/理论

1. 对nio有了解吗
2. 怎么保证幂等性
3. 为什么用docker，好处是什么
4. 你在项目中怎么用的docker
5. 怎么做的限流
6. 怎么防止超卖
7. 怎么保证幂等性
8. 怎么做的限流
9. 单例模式的创建；



redis/mysql

1. MYSQL中有哪些锁

2. 聚集索引和非聚集索引的区别

3. 意向锁是干什么的

4. 索引失效的情况；

5. 项目中使用的redis是单机还是集群

6. Redis的使用场景；

7. redis实现分布式锁是怎么实现的

8. 你在项目中哪些地方用到了分布式锁

   > 1. **分布式任务调度**：多个节点部署同一任务（如数据清理），需避免重复执行
   > 2. 资源竞争控制：**库存扣减、商品秒杀**
   > 3. *防止重复操作** ：**支付防重、订单幂等**，网络重试或用户重复提交导致多次扣款。



jvm

-  ==重点== 项目中是如何进行jvm调优的?
- 了解哪些垃圾收集器, 说说G1和CMS的区别
- 类加载机制
-  Jvm的作用
-  ==重点==垃圾回收器，垃圾回收算法；
- ==重点==GC ROOT对象有哪些
- 垃圾回收有哪些算法
- 标记清除算法的原理
- 有jvm调优的经验吗
- 怎么判断一个对象能否被回收

java

- TreeMap和HashMap的区别. 
- Arraylist和linkedlist的区别；
- ==和equals
- 深浅拷贝
- hashmap底层原理
- cucrrentHashMap 底层
- sybchronized的实现原理
- 线程同步的方式
- 了解多线程吗?
- volatile的作用，什么是可见性和有序性



Spring/springboot

-  spring boot和spring的区别.
- spring boot启动过程都发生了什么.
- spring的依赖注入是怎么实现的?
- 在一个方法中改变了注入对象的属性, 另一个方法调用该属性是否改变? 
- springboot中怎么开启定时任务，是同步的吗
- spring中bean的生命周期，作用域



## 二, 答案

### 1, MYSQL中有哪些锁

> 全局锁，表锁，**页级锁（BDB引擎支持），**剪隙锁，行锁，共享，排他， 意向锁

**一、按锁的粒度分类**

1. **全局锁**
   - **FLUSH TABLES WITH READ LOCK (FTWRL)**
     锁定整个数据库实例，所有表变为只读状态，常用于备份操作。
   - **`mysqldump --single-transaction`** 或 **InnoDB** 的 **MVCC** 可避免全局锁。
2. **表级锁**
   - **普通表锁**
     - **表共享读锁（S）**：允许其他事务读，但禁止写（如 `LOCK TABLES ... READ`）。
     - **表独占写锁（X）**：禁止其他事务读写（如 `LOCK TABLES ... WRITE`），MyISAM 默认使用。
   - **意向锁（Intention Locks）**
     - **IS（意向共享锁）**：事务计划在表中某些行加共享锁。
     - **IX（意向排他锁）**：事务计划在表中某些行加排他锁。
     - 用于快速判断表级锁与行级锁的冲突（如 `ALTER TABLE` 需检查IX是否冲突）。
   - **AUTO-INC锁**
     自增列插入时使用的特殊表级锁，MySQL 8.0 后优化为轻量级原子操作。
   - **元数据锁（MDL）**
     防止表结构变更（如 `ALTER TABLE`）与读写操作冲突，分为共享（读）和排他（写）模式。
3. **行级锁（InnoDB支持）**
   - **记录锁（Record Locks）**
     锁定索引中的单条记录（若表无索引，则锁定隐式聚簇索引）。
   - ==**间隙锁（Gap Locks）**==
     锁定索引记录的间隙（如 `WHERE id BETWEEN 5 AND 10` 会锁定5-10间的空隙），防止幻读。
   - ==**临键锁（Next-Key Locks）**==
     记录锁 + 间隙锁，锁定左开右闭区间（默认在可重复读隔离级别下启用）。
   - **插入意向锁（Insert Intention Locks）**
     插入前在间隙设置的锁，标记插入意图，与其他间隙锁兼容性需判断。
4. **页级锁（BDB引擎支持）**
   锁定数据页，介于表锁和行锁之间，现已较少使用。

**二、按锁的类型分类**

1. **共享锁（S Lock）**
   - 允许其他事务读，禁止写（`SELECT ... LOCK IN SHARE MODE`）。
2. **排他锁（X Lock）**
   - 禁止其他事务读写（`SELECT ... FOR UPDATE` 或 DML 语句自动加锁）。 
   - UPDATE`、`DELETE

**三、其他特殊锁**

1. **预测锁（Predicate Locks）**
   用于空间索引（如GIS查询），锁定满足条件的记录范围。
2. **隐式锁与显式锁**
   - **隐式锁**：由存储引擎自动管理（如InnoDB的DML操作自动加行锁）。
   - **显式锁**：通过SQL语句手动控制（如 `LOCK TABLES`, `SELECT ... FOR UPDATE`）。



### 2.2 ，聚集索引和非聚集索引的区别

**数据存储方式**

|       **特性**       |     **聚集索引**（主键索引）     |        **非聚集索引**（二级索引）        |
| :------------------: | :------------------------------: | :--------------------------------------: |
| **索引与数据的关系** | 索引的叶子节点直接存储完整数据行 | 索引的叶子节点存储**主键值**或**行指针** |
|   **物理存储顺序**   |  数据行按聚集索引键值的顺序存储  |     数据行的物理存储顺序与索引键无关     |
|     **索引数量**     |     每个表仅能有一个聚集索引     |        每个表可以有多个非聚集索引        |

**示例说明**

- **聚集索引**：
  假设表 `users` 的主键为 `id`（聚集索引），数据行按 `id` 顺序存储在磁盘上。

  ```
  -- 数据物理存储示例（简化）
  | id (PK) | name  | age |
  |---------|-------|-----|
  | 1       | Alice | 25  | ← 数据页
  | 2       | Bob   | 30  | ← 相邻数据页
  | 3       | Carol | 28  | ← 相邻数据页
  ```

- **非聚集索引**：
  在 `users` 表的 `name` 列上创建非聚集索引，其叶子节点存储主键 `id`：

  ```
  -- 非聚集索引结构示例（简化）
  | name  | id (PK) |
  |-------|---------|
  | Alice | 1       |
  | Bob   | 2       |
  | Carol | 3       |
  ```

------

### **2. 查询性能对比**

|     **场景**     |           **聚集索引**           |               **非聚集索引**               |
| :--------------: | :------------------------------: | :----------------------------------------: |
|   **主键查询**   |    直接定位数据行（无需回表）    |     需先查索引，再通过主键回表获取数据     |
| **覆盖索引查询** |  不适用（数据直接存储在索引中）  | 若查询字段全在索引中，无需回表（性能最优） |
|   **范围查询**   | 高效（数据按顺序存储，连续读取） |            需多次回表，性能较低            |

**示例分析**

- **场景 1：通过主键查询用户信息**

  ```
  SELECT * FROM users WHERE id = 2;
  ```

  - **聚集索引**：直接定位到 `id=2` 的数据行，无需额外步骤。
  - **非聚集索引**：不涉及（主键本身就是聚集索引）。

- **场景 2：通过 `name` 查询用户年龄**

  ```
  SELECT age FROM users WHERE name = 'Bob';
  ```

  - **非聚集索引**：若索引为 `(name, age)`，直接返回 `age`（覆盖索引，无需回表）。
  - **非聚集索引**：若索引仅为 `(name)`，需先查 `name` 索引找到 `id=2`，再回表查询 `age`。

**3. 维护成本**

|   **操作**    |             **聚集索引**             |      **非聚集索引**      |
| :-----------: | :----------------------------------: | :----------------------: |
| **插入/删除** | 可能引起数据页分裂或合并（影响性能） | 仅更新索引结构，成本较低 |
| **更新主键**  |        代价高（需移动数据行）        | 若未修改索引键，无需更新 |

**优化建议**

- **聚集索引键选择**：优先使用 **自增整数** 作为主键，避免随机插入导致页分裂。
- **非聚集索引设计**：尽量实现覆盖索引（包含查询所需字段），减少回表开销。

**4. 适用场景**

|  **索引类型**  |           **适用场景**           |              **案例**              |
| :------------: | :------------------------------: | :--------------------------------: |
|  **聚集索引**  |   主键查询、范围扫描、排序操作   | 按时间范围查询订单、用户ID精确查找 |
| **非聚集索引** | 高频查询的非主键列、覆盖索引优化 |   根据商品名称搜索、用户邮箱登录   |

**5. 存储引擎差异**

- **InnoDB**：
  - 主键索引为聚集索引，数据按主键顺序存储。
  - 非聚集索引的叶子节点存储主键值，回表通过主键查找数据。
- **MyISAM**：
  - 所有索引均为非聚集索引，数据行独立存储（.MYD文件），索引存储行指针（.MYI文件）。
  - 主键索引与非聚集索引结构相同，无聚集索引概念。

**总结**

|   **维度**   |         **聚集索引**         |          **非聚集索引**          |
| :----------: | :--------------------------: | :------------------------------: |
| **核心角色** |     决定数据物理存储顺序     |         加速特定列的查询         |
| **性能优势** |    主键查询、范围扫描高效    | 覆盖索引场景高效，支持多索引优化 |
| **设计要点** | 主键应简洁、有序（如自增ID） |     按查询需求设计，避免冗余     |

合理选择索引类型，结合业务查询模式和数据量级，是优化 MySQL 性能的关键。聚集索引是数据存储的骨架，而非聚集索引是查询加速的利器。



### 2.3 意向锁是干什么的？

**意向锁的核心作用**

> 1. **快速冲突检测**：
>    - 当某个事务想加 **表级锁**（如 `LOCK TABLES ... WRITE`）时，只需检查表的意向锁状态，无需逐行遍历行锁。
>    - 例如：表级排他锁（X Lock）与任何意向锁（IS/IX）冲突，直接拒绝或等待。
> 2. **表达锁的意向**：
>    - 意向锁声明了事务的“意图”，允许系统提前判断锁的兼容性，避免不必要的阻塞。

**1. InnoDB 何时加表锁？**

InnoDB **默认以行级锁为主**，但在以下场景会使用表锁：

**(1) 执行 DDL 操作（表结构变更）**

- **场景**：执行 `ALTER TABLE`、`DROP TABLE`、`TRUNCATE TABLE` 等 DDL 语句时。

- 锁类型：

  - **元数据锁（Metadata Lock, MDL）**：隐式表锁，阻塞其他会话的 DDL 操作，但允许 DML 操作继续执行（除非涉及表结构冲突）。

- 示例：

  ```
  -- 会话1：执行 DDL（自动加 MDL 写锁）
  ALTER TABLE users ADD COLUMN email VARCHAR(255);
  
  -- 会话2：尝试执行 DDL 会被阻塞
  ALTER TABLE users DROP COLUMN age; -- 等待 MDL 锁释放
  ```

**(2) 显式使用 `LOCK TABLES` 命令**

- **场景**：手动执行 `LOCK TABLES` 强制加表锁（通常不建议在 InnoDB 中使用）。

- 锁类型：

  - **表级共享读锁（READ）**：允许其他会话读，阻塞写。
  - **表级排他写锁（WRITE）**：禁止其他会话读写。

- 示例：

  ```
  LOCK TABLES users WRITE; -- 显式加表级写锁
  -- 执行批量操作...
  UNLOCK TABLES;
  ```

**(3) 特殊情况下的锁升级（极少见）**

- **场景**：当行锁冲突过多或索引失效时，可能退化为表锁（但 InnoDB 通常不会自动升级锁）。

- 触发条件：

  - 全表扫描且无法使用索引（如 `WHERE` 条件无索引列）。
  - 显式事务中执行 `SELECT ... FOR UPDATE` 但无可用索引。
  
- 示例：

  ```
  -- 无索引的查询可能触发隐式表锁
  SELECT * FROM users WHERE phone = '123456' FOR UPDATE; -- 若 phone 列无索引
  ```

**2. InnoDB 何时加意向锁？**

意向锁（Intention Locks）是 **表级锁**，用于快速判断表级锁与行级锁的冲突。InnoDB **自动管理意向锁**，无需手动干预。

**(1) 意向共享锁（IS Lock）**

- **触发条件**：事务准备对某些行加 **共享锁（S Lock）**。

- SQL 操作：

  ```
  SELECT ... LOCK IN SHARE MODE;
  ```

**(2) 意向排他锁（IX Lock）**

- **触发条件**：事务准备对某些行加 **排他锁（X Lock）**。

- SQL 操作：

  ```
  SELECT ... FOR UPDATE;
  INSERT / UPDATE / DELETE; -- 写操作自动加 IX 锁
  ```

**(3) 意向锁的作用**

- 冲突检测：

  - 若其他事务持有表级锁（如 `LOCK TABLES ... WRITE`），意向锁会立即冲突，避免逐行检查行锁。

- 兼容性规则：

  | **当前锁** | **IS** | **IX** | **S** | **X** |
  | :--------: | :----: | :----: | :---: | :---: |
  |   **IS**   |  兼容  |  兼容  | 兼容  | 冲突  |
  |   **IX**   |  兼容  |  兼容  | 冲突  | 冲突  |
  |   **S**    |  兼容  |  冲突  | 兼容  | 冲突  |
  |   **X**    |  冲突  |  冲突  | 冲突  | 冲突  |



## 2.4, 索引失效的情况？

> 1. 函数计算
> 2. 隐式类型转换 -比如字段是VARCHAR类型，但查询的时候用了数字
> 3. 最左匹配原则- 联合索引

MySQL 索引失效的常见情况及原因分析如下：

------

### **1. 违反最左前缀原则（联合索引）**

- **场景**：联合索引 `(a, b, c)`，但查询未从最左列开始或跳过中间列。

  ```
  -- 失效：未使用 a
  SELECT * FROM table WHERE b = 1 AND c = 2;
  
  -- 部分失效：仅 a 有效，c 无法利用索引
  SELECT * FROM table WHERE a = 1 AND c = 3;
  ```

------

### **2. 对索引列使用函数或表达式**

- **原因**：索引存储原始值，计算后的值无法匹配索引。

  ```
  -- 失效：对列使用函数
  SELECT * FROM table WHERE UPPER(name) = 'ALICE';
  
  -- 失效：列参与运算
  SELECT * FROM table WHERE age + 1 = 20;
  ```

------

### **3. 隐式类型转换**

- **场景**：索引列与条件值类型不一致，触发隐式转换。

  ```
  -- 失效：字段为 VARCHAR，但条件为数字（需转字符串）
  SELECT * FROM table WHERE varchar_column = 123;
  
  -- 失效：字段为 INT，但条件为字符串（需转数字）
  SELECT * FROM table WHERE int_column = '123';
  ```

------

### **4. 使用 `OR` 连接非索引列**

- **规则**：若 `OR` 任意一列无索引，则全表扫描。

  ```
  -- 失效：若 column2 无索引
  SELECT * FROM table WHERE indexed_column = 1 OR column2 = 2;
  ```

------

### **5. 范围查询后的索引列失效**

- **联合索引中**：范围查询（`>`、`<`、`BETWEEN`）后的列无法使用索引。

  ```
  -- 索引 (a, b, c)
  SELECT * FROM table WHERE a = 1 AND b > 10 AND c = 5; -- 仅 a 和 b 使用索引
  ```

------

### **6. 使用 `!=` 或 `<>` 操作符**

- **原因**：非等值查询需扫描大部分数据，优化器可能放弃索引。

  ```
  SELECT * FROM table WHERE status != 'active';
  ```

------

### **7. `LIKE` 以通配符开头**

- **失效**：`LIKE '%abc'` 无法利用前缀索引。

  ```
  -- 失效：以 % 开头
  SELECT * FROM table WHERE name LIKE '%abc';
  
  -- 有效：以固定前缀开头
  SELECT * FROM table WHERE name LIKE 'abc%';
  ```

------

### **8. 数据量过少**

- **优化器决策**：当数据量极小时，全表扫描可能比索引更快。

------

### **9. 统计信息不准确**

- **解决**：执行 `ANALYZE TABLE table_name` 更新统计信息。

------

### **10. 使用 `IN` 或 `NOT IN`**

- **潜在失效**：参数过多时优化器可能选择全表扫描。

  ```
  SELECT * FROM table WHERE id IN (1, 2, 3, ..., 1000);
  ```

------

### **11. 字符集/排序规则不匹配**

- **联表查询**：不同表的字符集或排序规则不同，导致隐式转换。

------

### **排查工具**

使用 `EXPLAIN` 分析查询计划：

- 检查 `possible_keys` 和 `key` 确认是否使用索引。
- `type` 列若为 `ALL` 表示全表扫描。

------

### **优化建议**

1. 避免在索引列上使用函数或计算。
2. 确保条件类型与索引列类型一致。
3. 合理设计联合索引顺序，高频查询字段靠左。
4. 使用覆盖索引（查询字段全在索引中）减少回表。

通过理解这些场景，可以有效避免索引失效并提升查询性能。





## 1.7，项目中使用的redis是单机还是集群



## 1.8, redis实现分布式锁是怎么实现的

### ** 基础实现（单节点 Redis）**

#### **获取锁**

使用 `SET` 命令的 `NX`（不存在才设置）和 `PX`（过期时间）参数：

```
SET lock_key unique_value NX PX 30000
```

- **`lock_key`**：锁的唯一标识（如 `resource_lock`）。
- **`unique_value`**：客户端生成的唯一值（如 UUID），用于安全释放锁。
- **`NX`**：仅当键不存在时才设置成功。
- **`PX 30000`**：锁的自动过期时间（单位毫秒），防止死锁。

#### **释放锁**

使用 Lua 脚本保证 **原子性删除**：

```
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

- 检查锁的值是否匹配 `unique_value`，避免误删其他客户端的锁。

------

### **2. 关键问题与解决方案**

#### **问题 1：锁过期但业务未执行完**

- **场景**：锁自动过期，但客户端仍在操作共享资源。

- **解决**：使用 **看门狗（Watchdog）** 机制，启动后台线程定期续期锁：

  ```
  -- 续期脚本（每 10 秒执行一次）
  if redis.call("GET", KEYS[1]) == ARGV[1] then
      return redis.call("PEXPIRE", KEYS[1], ARGV[2])
  else
      return 0
  end
  ```

#### **问题 2：Redis 主从架构的锁失效**

- **场景**：主节点宕机，锁未同步到从节点，导致锁被重复获取。
- **解决**：使用 **RedLock 算法**（多节点 Redis 集群）：
  1. 客户端依次向多个独立 Redis 节点请求加锁。
  2. 当大多数节点（如 3/5）加锁成功，且总耗时小于锁过期时间，视为加锁成功。
  3. 释放锁时向所有节点发送删除请求。

------

### **3. RedLock 算法实现步骤**

1. **获取当前时间**（精确到毫秒）。
2. **依次向 N 个 Redis 节点请求加锁**，使用相同的 `key` 和 `unique_value`。
3. **计算加锁耗时**：
   - 如果耗时超过锁的过期时间，直接失败。
4. **验证多数节点是否成功**：
   - 成功节点数 ≥ N/2 + 1（如 3/5），则视为加锁成功。
5. **锁的实际有效期** = 初始过期时间 - 加锁耗时。
6. **释放锁**：向所有节点发送 Lua 删除脚本。

------

### **4. 代码示例（Python + Redisson）**

```
import redis
import time
import uuid

class RedisDistributedLock:
    def __init__(self, redis_nodes, lock_key, expire_time=30000):
        self.redis_conns = [redis.StrictRedis(**node) for node in redis_nodes]
        self.lock_key = lock_key
        self.expire_time = expire_time
        self.identifier = str(uuid.uuid4())

    def acquire(self):
        start_time = time.time() * 1000
        success_nodes = 0

        # 尝试在所有节点加锁
        for conn in self.redis_conns:
            try:
                if conn.set(self.lock_key, self.identifier, nx=True, px=self.expire_time):
                    success_nodes += 1
            except:
                continue  # 忽略节点故障

        # 计算加锁耗时
        elapsed_time = time.time() * 1000 - start_time
        if success_nodes >= len(self.redis_conns) // 2 + 1 and elapsed_time < self.expire_time:
            return True
        else:
            self.release()  # 加锁失败，释放已获取的锁
            return False

    def release(self):
        for conn in self.redis_conns:
            try:
                script = """
                if redis.call("GET", KEYS[1]) == ARGV[1] then
                    return redis.call("DEL", KEYS[1])
                else
                    return 0
                end
                """
                conn.eval(script, 1, self.lock_key, self.identifier)
            except:
                pass
```

------

### **5. 最佳实践**

1. **设置合理的过期时间**：根据业务操作的最大耗时调整。
2. **避免长时间阻塞**：获取锁失败后，采用重试机制（如指数退避）。
3. **唯一标识（unique_value）**：确保锁只能由持有者释放。
4. **网络分区处理**：在 RedLock 中容忍少数节点故障，但需权衡 CAP。

------

### **6. 常见问题**

- **Q：Redis 分布式锁能否完全替代 ZooKeeper？**
  - **A**：Redis 性能更高，但在极端故障场景下，ZooKeeper 的临时节点和 Watcher 机制更可靠。
- **Q：锁被其他客户端释放怎么办？**
  - **A**：必须通过 `unique_value` 验证锁的归属。

------

通过以上方法，Redis 可以实现高效、可靠的分布式锁，适用于大部分高并发场景。对于强一致性要求的场景，建议结合 RedLock 或多方案混合使用。



## 三，为什么锁的释放需要原则性？



### **1. 释放锁的流程**

一个安全的锁释放需要两步操作：

1. **检查锁的持有者**：确认当前锁的值（如 UUID）是否由当前客户端设置。
2. **删除锁**：如果是当前客户端持有的锁，则删除。

这两个操作必须原子性执行，否则会出现竞态条件。

------

### **2. 非原子性释放锁的隐患**

如果直接分两步执行（先 `GET` 后 `DEL`），可能发生以下问题：

#### **场景示例**

1. **客户端 A** 获取锁，值为 `uuid_A`，过期时间 10 秒。
2. 客户端 A 完成操作后，先执行 `GET lock_key`，发现值为 `uuid_A`。
3. 在客户端 A 执行 `DEL lock_key` **之前**，锁因过期自动释放。
4. **客户端 B** 立即获取锁，值为 `uuid_B`。
5. 客户端 A 继续执行 `DEL lock_key`，**误删了客户端 B 的锁**。
6. 此时客户端 C 也可能获取锁，导致多个客户端同时操作临界资源。

#### **后果**

- 锁的互斥性被破坏，多个客户端同时操作共享资源，引发数据不一致。
- 系统可能发生不可预测的并发问题（如重复扣款、超卖等）。







