jvm

-  ==重点== 项目中是如何进行jvm调优的?
-  了解哪些垃圾收集器, 说说G1和CMS的区别
-  类加载机制
-  Jvm的作用
-  ==重点==垃圾回收器，垃圾回收算法；
-  ==重点==GC ROOT对象有哪些
-  垃圾回收有哪些算法
-  标记清除算法的原理
-  有jvm调优的经验吗
-  怎么判断一个对象能否被回收
-  jmm 是什么？





## 2,项目中是如何进行jvm调优的?

在项目中，JVM调优是一个结合监控、分析、实验和验证的持续过程，目的是解决性能问题（如GC频繁、内存泄漏、高延迟、低吞吐量等）。以下是典型的调优流程和关键点：

------

### **1. 明确调优目标**

- **核心指标**：吞吐量（Throughput）、延迟（Latency）、内存占用（Footprint）。
- 典型场景：
  - 减少Full GC频率（避免长时间停顿）。
  - 降低Young GC时间（优化短生命周期对象回收）。
  - 避免OOM（内存泄漏或容量不足）。
  - 提升应用响应速度（如减少GC停顿对用户体验的影响）。

------

### **2. 监控与诊断**

#### **工具与数据收集**

- 基础工具：

  - `jstat`：查看堆内存、GC次数、耗时（如 `jstat -gcutil <pid> 1000`）。
  - `jmap`：生成堆转储（Heap Dump）分析内存分布（`jmap -dump:format=b,file=heap.hprof <pid>`）。
  - `jstack`：抓取线程快照，排查死锁或线程阻塞问题。
  - `jcmd`：综合诊断工具（如 `jcmd <pid> VM.flags` 查看JVM参数）。
  
- 可视化工具：

  - **VisualVM**、**JConsole**：实时监控堆、线程、类加载情况。
  - **MAT（Memory Analyzer Tool）**：分析Heap Dump，定位内存泄漏。
  - **GCEasy**：在线分析GC日志，生成可视化报告。
  
- GC日志：

  - 启动参数中添加 `-Xloggc:/path/to/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps`。
- 关注 `Full GC` 频率、`Young GC` 耗时、对象晋升老年代的速度。

------

### **3. 关键调优参数**

#### **堆内存分配**

- **初始堆和最大堆**：`-Xms` 和 `-Xmx`（通常设置为相同值，避免动态调整开销）。

- 新生代与老年代比例：

  - `-XX:NewRatio=2`（老年代:新生代=2:1）。
  - 新生代中Eden和Survivor比例：`-XX:SurvivorRatio=8`（Eden:Survivor=8:1:1）。
  
- 元空间（Metaspace）：

  - `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize`（避免频繁Full GC）。

#### **垃圾收集器选择**

- **吞吐量优先**：`-XX:+UseParallelGC`（Parallel Scavenge + Parallel Old）。

- 低延迟优先：

  - CMS：`-XX:+UseConcMarkSweepGC`（JDK 8及之前）。
  - G1：`-XX:+UseG1GC`（JDK 9+默认，适合大堆内存）。
  - ZGC/Shenandoah：`-XX:+UseZGC` 或 `-XX:+UseShenandoahGC`（亚毫秒级停顿，JDK 11+）。

#### **GC策略优化**

- **避免晋升失败**：增大Survivor区或调整 `-XX:MaxTenuringThreshold`（对象晋升年龄阈值）。
- **大对象直接进入老年代**：`-XX:PretenureSizeThreshold`（避免大对象在新生代复制）。
- **Full GC触发条件**：CMS需关注 `-XX:CMSInitiatingOccupancyFraction`（老年代占用率触发阈值）。

------

### **4. 常见问题与解决思路**

#### **频繁Full GC**

- 可能原因：
  - 老年代空间不足（内存泄漏或Survivor区过小导致对象过早晋升）。
  - System.gc() 被显式调用（可通过 `-XX:+DisableExplicitGC` 禁用）。
- 解决方案：
  - 分析Heap Dump，定位内存泄漏（如未关闭的数据库连接、缓存未清理）。
  - 调整新生代大小或晋升阈值。

#### **Young GC时间长** :吞吐量下降

- **可能原因**：新生代过大导致单次GC耗时增加。
- **解决方案**：适当减小新生代（需平衡GC频率和单次耗时）。

#### **Metaspace OOM**

- **可能原因**：动态生成类（如反射、CGLIB代理）未释放。
- **解决方案**：增大 `-XX:MaxMetaspaceSize`，或修复类加载泄漏。

------

### **5. 实战案例**

#### **案例1：电商系统Full GC频繁**

- **现象**：每天高峰期频繁Full GC，接口超时。
- **分析**：Heap Dump显示老年代中存在大量未释放的订单缓存对象。
- 解决：
  1. 修复缓存未设置TTL的问题。
  2. 调整堆大小：`-Xms4g -Xmx4g -XX:NewRatio=1`（增大新生代）。
  3. 切换为G1收集器：`-XX:+UseG1GC -XX:MaxGCPauseMillis=200`。

#### **案例2：大数据应用Young GC频繁**

- **现象**：Young GC每秒超过10次，影响吞吐量。
- **分析**：`jstat` 显示对象存活时间极短，Survivor区溢出。
- **解决**：增大新生代 `-Xmn2g`，调整 `-XX:SurvivorRatio=6`。

------

### **6. 调优原则**

1. **优先定位问题，再调参**：避免盲目调整参数。
2. **小步迭代**：每次只调整1-2个参数，观察效果。
3. **结合业务场景**：如高并发低延迟选G1/ZGC，离线计算选Parallel GC。
4. **监控常态化**：集成Prometheus + Grafana监控JVM指标。



## 2, Stop-the-word那些情况会产生？

各种回收器的对比







## 2.1,Jvm是什么？它的作用

> 1. 定义是什么
> 2. 有什么作用-特别的 优缺点
> 3. 组成部分是什么

### **JVM 是什么？**

- **虚拟机概念**：JVM 是一个通过软件模拟的计算机，能够在物理机器上运行，提供与硬件无关的编程环境。
- **字节码执行**：它负责执行Java编译器生成的中间代码（字节码，`.class`文件），而非直接执行Java源代码或特定平台的机器码。

### **核心作用**

1. **跨平台运行（Write Once, Run Anywhere）**
   - JVM 针对不同操作系统和硬件提供统一接口，同一份字节码可在任何安装了JVM的设备上运行，消除平台差异。
2. **内存管理与垃圾回收（GC）**
   - **自动内存分配**：管理堆内存（存储对象实例）和栈内存（方法调用、局部变量）。
   - **垃圾回收**：自动回收不再使用的对象内存，减少内存泄漏风险，开发者无需手动释放内存。
3. **即时编译（JIT）优化**
   - **解释执行**：初始逐行解释字节码，启动快但效率低。
   - **JIT编译**：识别热点代码（频繁执行的代码段），编译为本地机器码以提高执行速度，平衡启动与运行效率。
4. **类加载与安全机制**
   - **类加载器**：动态加载、链接和初始化类文件，支持模块化应用。
   - **安全验证**：字节码验证器检查代码合法性，防止非法操作（如内存越界），保障运行环境安全。
5. **多语言支持**
   - 任何能编译成JVM字节码的语言（如Kotlin、Scala、Groovy）均可运行于JVM，利用其生态与性能优势。

### **JVM 核心组件**

- **类加载器（Class Loader）**：加载字节码到内存。
- **运行时数据区**：包括方法区（类结构）、堆（对象）、栈（线程私有数据）、程序计数器、本地方法栈。
- **执行引擎**：含解释器、JIT编译器（如HotSpot），负责执行或编译字节码。
- **本地接口（JNI）**：支持调用C/C++等本地库。
- 本地库

### **优缺点**

- **优点**：跨平台、自动内存管理、丰富的工具生态（监控、调试）、多语言支持。
- **缺点**：启动时间较长、内存占用较高（可通过调优或GraalVM等改进）。

### **示例流程**

1. 编写Java代码 `Hello.java`。
2. 编译为字节码 `Hello.class`。
3. JVM加载字节码，由类加载器解析并存入方法区。
4. 执行引擎解释或JIT编译为机器码，CPU执行。
5. 运行中，GC自动回收堆内存中的废弃对象。

### **总结**

JVM是Java生态的基石，通过抽象硬件层实现跨平台能力，同时提供内存管理、性能优化及安全防护，使开发者专注于业务逻辑，无需深陷底层细节。其设计理念也推动了多语言生态的繁荣。



## 2.3,类加载的总的流程

> 1.  加载，连接（验证，准备，解析），初始

### **一、类加载的总体流程**

类加载过程分为 **加载（Loading）→ 连接（Linking）→ 初始化（Initialization）** 三个阶段，其中 **连接阶段** 又分为 **验证（Verification）→ 准备（Preparation）→ 解析（Resolution）** 三个子阶段。

```
1. 加载（Loading）
2. 连接（Linking）
   ├─ 验证（Verification）
   ├─ 准备（Preparation）
   └─ 解析（Resolution）
3. 初始化（Initialization）
```

------

### **二、类加载的详细步骤**

#### **1. 加载（Loading）**

- **任务**：查找并加载类的二进制字节码（`.class`文件）。
- **具体操作**：
  - 通过类的全限定名（如 `java.lang.String`）查找字节码文件。
  - 将字节码的静态存储结构（文件格式）转换为方法区的运行时数据结构。
  - 在内存中生成一个代表该类的 `Class` 对象（存放在堆中），作为访问类数据的入口。
- **加载来源**：
  - 本地文件系统（如普通的 Java 类）。
  - 网络资源（如 Applet）。
  - 动态生成（如动态代理生成的类）。

#### **2. 连接（Linking）**

##### **(1) 验证（Verification）**

- **目的**：确保字节码符合 JVM 规范，防止恶意代码破坏 JVM。
- **验证内容**：
  - 文件格式验证（是否以 `0xCAFEBABE` 开头）。
  - 元数据验证（是否符合 Java 语言规范，如继承关系）。
  - 字节码验证（确保指令不会导致 JVM 崩溃）。
  - 符号引用验证（确保引用的类、方法、字段存在）。

##### **(2) 准备（Preparation）**

- **任务**：为类的静态变量分配内存并设置初始值。
- **注意**：
  - 分配的内存是方法区中的内存。
  - 初始值是数据类型的默认值（如 `int` 为 `0`，`boolean` 为 `false`），而非代码中显式赋的值。
  - 如果静态变量是 `final` 常量（如 `static final int x = 123`），则直接赋值为代码中定义的值。

##### **(3) 解析（Resolution）**

- **任务**：将符号引用（常量池中的引用）转换为直接引用（内存地址）。
- **解析对象**：
  - 类或接口的解析。
  - 字段解析（如 `User.name`）。
  - 方法解析（如 `User.getName()`）。

#### **3. 初始化（Initialization）**

- **任务**：执行类的初始化代码（静态代码块 `static {}` 和静态变量显式赋值）。
- **触发条件**：
  - 首次创建类的实例（`new`）。
  - 访问类的静态变量或静态方法（除非是 `final` 常量）。
  - 反射调用（如 `Class.forName("User")`）。
  - 子类初始化时，父类需先初始化。
- **执行顺序**：
  1. 父类初始化（如果未初始化）。
  2. 按代码顺序执行静态变量显式赋值和静态代码块。



## 2.2,类加载器 ClassLoader

JVM 通过类加载器实现类的动态加载，采用 **双亲委派模型（Parent Delegation Model）**。

#### **1. 类加载器的层次结构**

1. **Bootstrap Class Loader（启动类加载器）**
   - C++ 实现，加载 `JAVA_HOME/lib` 下的核心类（如 `java.lang.*`）。
   - 唯一没有父加载器的加载器。
2. **Extension Class Loader（扩展类加载器）**
   - 加载 `JAVA_HOME/lib/ext` 或 `java.ext.dirs` 指定的类。
3. **Application Class Loader（应用类加载器）**
   - 默认加载用户类路径（`-classpath`）的类，是程序的默认类加载器。
4. **自定义类加载器**
   - 继承 `ClassLoader`，重写 `findClass()` 方法，实现动态加载（如热部署、加密类文件）。

#### **2. 双亲委派模型**

- **工作流程**：
  1. 子加载器收到加载请求时，先委派给父加载器。
  2. 父加载器无法完成时（如找不到类），子加载器才尝试加载。
- **优点**：
  - 避免核心类被重复加载（如 `java.lang.Object`）。
  - 防止用户自定义类覆盖核心类（如自定义 `java.lang.String` 会被父加载器拦截）。
- 缺点：
  -  单向，父类加载器无法加载子类加载器中 类。

#### **3. 打破双亲委派的场景**

- **SPI（Service Provider Interface）**
  - 核心接口由 Bootstrap 加载器加载，实现类由线程上下文类加载器加载（如 JDBC 驱动）。
- **OSGi 模块化**
  - 每个模块有独立的类加载器，实现模块间类隔离。
- **Tomcat 的类加载器**
  - Web 应用优先加载自身类，避免不同应用的类冲突。

------

### **三、类加载的常见问题**

1. **`ClassNotFoundException`**
   - **原因**：类加载器在类路径中找不到指定类（如依赖缺失）。
   - **解决**：检查类路径配置或依赖引入。
2. **`NoClassDefFoundError`**
   - **原因**：编译时存在类，但运行时找不到（如类初始化失败后再次加载）。
   - **解决**：检查类初始化逻辑（如静态代码块是否抛出异常）。
3. **类加载的线程安全**
   - JVM 保证一个类只会被加载一次，且加载过程是线程安全的

### 四，缺点和优点

| 场景       | 打破双亲委派的目的                | 实现方式                         | 典型应用           |
| :--------- | :-------------------------------- | :------------------------------- | :----------------- |
| **SPI**    | 父加载器需调用子加载器加载实现类  | 线程上下文类加载器反向委派       | JDBC 驱动加载      |
| **OSGi**   | 模块间类隔离，支持多版本共存      | 每个模块独立加载器，网状依赖关系 | Eclipse 插件系统   |
| **Tomcat** | 不同 Web 应用使用相同库的不同版本 | WebApp 类加载器优先加载自身类    | 多 Spring 版本部署 |



## 2.3,==重点== 项目中是如何进行jvm调优的?

在项目中进行 JVM 调优是一个结合监控、分析和调整的复杂过程，目的是提高应用性能、减少垃圾回收（GC）停顿时间、降低内存占用或避免内存溢出（OOM）。以下是具体的调优思路和步骤：

------

### **1. 理解 JVM 内存结构**

调优的前提是熟悉 JVM 内存模型，核心区域包括：

- **堆（Heap）**：对象实例存储区域，分为 **新生代（Young Generation）** 和 **老年代（Old Generation）**。
  - 新生代：Eden 区（新对象分配区） + Survivor 区（存活对象暂存区）。
  - 老年代：长期存活对象。
- **方法区（Metaspace）**：类元数据、常量池等（JDK8+ 取代 PermGen）。
- **虚拟机栈（Stack）**：线程私有的方法调用和局部变量。
- 程序计数器：(program counter）
- 本地方法栈：

------

### **2. 调优的核心步骤**

#### **(1) 确定问题与目标**

- **常见问题**：
  - Full GC 频繁（应用卡顿、延迟高）。
  - Young GC 时间过长（吞吐量下降）。
  - OOM（内存溢出，如 `java.lang.OutOfMemoryError`）。
  - Metaspace 或堆外内存泄漏。
- **目标**：
  - 降低 GC 停顿时间（如从 1秒 降至 200ms）。
  - 提高吞吐量（如从 95% 提升至 99%）。
  - 避免内存溢出。

#### **(2) 监控与分析**

- **工具**：
  - **`jstat`**：查看 GC 统计（如 `jstat -gcutil <pid> 1000` 每秒打印一次）。
  - **`jmap`** + **MAT（Memory Analyzer Tool）**：生成堆转储（Heap Dump），分析内存泄漏。
  - **`jstack`**：分析线程阻塞或死锁。
  - **VisualVM / JConsole**：图形化监控堆、线程、类加载。
  - **GCEasy**：在线分析 GC 日志。
  - **Arthas**：实时诊断线上问题。
- **关键指标**：
  - **堆内存使用率**：是否频繁达到上限？
  - **GC 频率与耗时**：Young GC / Full GC 的次数和时间。
  - **对象分配速率**：观察 `jstat -gc <pid>` 中的 `YGC` 和 `YGCT`。
  - **对象存活周期**：是否大量短生命周期对象进入老年代？

#### **(3) 调整 JVM 参数**

- **基础参数**：

  - **堆大小**：`-Xms`（初始堆）、`-Xmx`（最大堆），设为相同值避免动态调整开销。
  - **新生代与老年代比例**：`-XX:NewRatio=2`（老年代:新生代=2:1）。
  - **Eden 与 Survivor 比例**：`-XX:SurvivorRatio=8`（Eden:Survivor =8:1）。
  - **Metaspace 大小**：`-XX:MetaspaceSize=256m`、`-XX:MaxMetaspaceSize=256m`（避免动态扩展）。

- **GC 算法选择**：

  - **高吞吐量**：`-XX:+UseParallelGC`（Parallel Scavenge + Parallel Old）。
  - **低延迟**：
    - `-XX:+UseG1GC`（G1，JDK9+ 默认）。
    - `-XX:+UseZGC`（JDK11+，超大堆场景）。
    - `-XX:+UseShenandoahGC`（低停顿，JDK12+）。
  - **CMS（已废弃，JDK14+移除）**：`-XX:+UseConcMarkSweepGC`（关注停顿时间的老年代并发回收）。

- **高级参数示例**：

  ```
  # G1 调优示例
  -XX:+UseG1GC 
  -XX:MaxGCPauseMillis=200  # 目标停顿时间
  -XX:InitiatingHeapOccupancyPercent=45  # 触发并发周期的堆占用率
  
  # 避免 Full GC 的逃生措施
  -XX:+ExplicitGCInvokesConcurrent  # 避免 System.gc() 触发 Full GC（如 Netty 堆外内存管理）
  ```

#### **(4) 代码优化**

- **减少内存泄漏**：避免静态集合持有对象、未关闭的资源（如数据库连接、流）。
- **优化对象生命周期**：
  - 减少大对象分配（如缓存超大数组）。
  - 使用对象池（如数据库连接池）。
- **选择合适的数据结构**：如 `ArrayList` vs `LinkedList`，避免 `HashMap` 未指定初始大小。

------

### **3. 常见场景与案例**

#### **案例1：频繁 Full GC**

- **现象**：应用每隔几分钟发生 Full GC，耗时 2 秒。
- **分析**：
  - 通过 `jstat` 发现老年代占用快速上升。
  - 堆转储分析（MAT）显示某个缓存类持有大量无效对象。
- **解决**：
  - 调整缓存策略，设置过期时间或 LRU 淘汰。
  - 增加老年代大小（`-XX:NewRatio=3`）。

#### **案例2：Young GC 时间过长**

- **现象**：Young GC 每次耗时 500ms。
- **分析**：
  - `jstat` 显示 Survivor 区空间不足，对象过早晋升到老年代。
  - Eden 区过小，导致频繁 Young GC。
- **解决**：
  - 增大新生代（`-Xmn2g`）。
  - 调整 Survivor 比例（`-XX:SurvivorRatio=4`）。

#### **案例3：Metaspace OOM**

- **现象**：`java.lang.OutOfMemoryError: Metaspace`。
- **分析**：
  - 动态生成类（如反射、CGLIB）未释放。
  - 默认 Metaspace 过小。
- **解决**：
  - 增加 `-XX:MaxMetaspaceSize=512m`。
  - 检查代码，避免重复类加载（如 Spring 热部署问题）。

------

### **4. 调优注意事项**

1. **避免过度优化**：调优需以监控数据为依据，而非盲目调整参数。
2. **关注业务场景**：
   - **Web 应用**：关注低延迟（G1/ZGC）。
   - **大数据计算**：关注高吞吐（Parallel GC）。
3. **分阶段调整**：每次只调整一个参数，观察效果。
4. **日志与监控**：
   - 开启 GC 日志：`-Xloggc:/path/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps`。
   - 结合 APM 工具（如 SkyWalking、Prometheus + Grafana）。
5. **环境一致性**：测试环境与生产环境的 JVM 参数、硬件配置尽量一致。

------

### **总结**

JVM 调优是一个持续的过程，需结合监控工具、业务场景和代码优化。核心思路是：

1. **监控分析** → 2. **定位瓶颈** → 3. **调整参数/代码** → 4. **验证效果**。
   最终目标不是追求“最优参数”，而是在吞吐量、延迟、内存占用之间找到平衡点。



### **频繁 Full GC 或长时间 GC 停顿**

- **现象**：应用出现卡顿，GC 日志中 `Full GC` 频繁（如每秒多次），或单次 `Stop-The-World` 时间过长（超过 1 秒）。
- **示例**：老年代（Old Generation）空间不足，导致频繁触发 Full GC。
- **优化方法**：
  - 增大堆内存（`-Xmx` 和 `-Xms`）。
  - 调整新生代与老年代比例（`-XX:NewRatio`）。
  - 更换低延迟垃圾回收器（如 `G1` 或 `ZGC`）。

------

### 2. **Young GC 过于频繁**

- **现象**：Minor GC 每秒多次，新生代对象存活时间过短。
- **示例**：短生命周期的对象过多（如循环中频繁创建临时对象），导致新生代 Eden 区快速填满。
- **优化方法**：
  - 增大新生代大小（`-Xmn`）。
  - 优化代码减少对象创建（如重用对象、使用基本类型）。

------

### 3. **元空间（Metaspace）溢出**

- **现象**：`java.lang.OutOfMemoryError: Metaspace` 错误。
- **示例**：动态生成大量类（如使用 CGLIB 或反射生成代理类）。
- **优化方法**：
  - 增大元空间大小（`-XX:MaxMetaspaceSize`）。
  - 检查类加载器泄漏（如未关闭的 Web 应用上下文）。

------

### 4. **高 CPU 使用率**

- **现象**：JVM 进程占用 CPU 超过预期（如持续 90%+）。
- **示例**：
  - **死循环**：代码中存在未正确退出的循环。
  - **锁竞争**：大量线程阻塞在 `synchronized` 或 `ReentrantLock` 上。
- **优化方法**：
  - 使用 `jstack` 或 `Async Profiler` 抓取线程栈，定位热点代码。
  - 减少锁粒度或用无锁数据结构（如 `ConcurrentHashMap`）。







## 2.4,==重点==垃圾回收器，垃圾回收算法,不同垃圾回收器应用场景。

> - Serial： 单线程，内存小 嵌入式
> - Parallel： 吞吐优先- 适合后台处理，不介意停顿的应用。数据报表（数据长期缓存）；科学计算应用；
> - cms，g1:   g1 jdk9 默认 是cms 的替代品，平衡吞吐量与延迟； web 应用，Android应用
> - ZGC和Shenandoah：是低延迟的优先，游戏服务器

### **一、垃圾回收算法**

1. **标记-清除（Mark-Sweep）**
   - **原理**：标记存活对象，清除未标记对象。
   - **优点**：实现简单，无需移动对象。
   - **缺点**：内存碎片化，可能触发 Full GC。
2. **标记-整理（Mark-Compact）**
   - **原理**：标记存活对象后，整理内存到一端。
   - **优点**：避免内存碎片。
   - **缺点**：整理过程耗时，增加停顿时间（STW）。
3. **复制（Copying）**
   - **原理**：将存活对象复制到另一块内存，清空原区域。
   - **优点**：无碎片，分配高效（指针碰撞）。
   - **缺点**：内存利用率低（需保留一半空间）。

### **二、JVM 垃圾回收器**

#### **1. Serial 收集器**

- **分代**：新生代（Serial） + 老年代（Serial Old）
- **算法**：复制算法（新生代） + 标记-整理（老年代）
- **特点**：单线程，全程 STW。
- **优点**：简单高效，无线程交互开销。
- **缺点**：停顿时间长，不适合大堆。
- **场景**：客户端应用或小内存服务器。

#### **2. Parallel Scavenge（吞吐量优先）**

- **分代**：新生代（Parallel Scavenge） + 老年代（Parallel Old）
- **算法**：复制算法（新生代） + 标记-整理（老年代）
- **特点**：多线程并行，关注吞吐量（`-XX:MaxGCPauseMillis`、`-XX:GCTimeRatio`）。
- **优点**：高吞吐量，适合后台计算。
- **缺点**：停顿时间不可控。
- **场景**：大数据处理、科学计算。

#### **3. ParNew 收集器**

- **分代**：新生代（ParNew）
- **算法**：复制算法
- **特点**：Serial 的多线程版本，需与 CMS 配合使用。
- **优点**：多线程缩短新生代停顿时间。
- **缺点**：依赖老年代收集器（如 CMS）。
- **场景**：与 CMS 搭配的 Web 服务。

#### **4. CMS（Concurrent Mark-Sweep）**

- **分代**：老年代
- **算法**：标记-清除
- **特点**：并发标记，减少 STW 时间（分 4 阶段：初始标记、并发标记、重新标记、并发清除）。
- **优点**：低停顿，适合交互式应用。
- **缺点**：
  - 内存碎片（需 Full GC 时触发压缩）。
  - CPU 敏感（并发阶段占用线程）。
  - 无法处理浮动垃圾（Concurrent Mode Failure）。
- **场景**：对延迟敏感的 Web 服务（JDK 9 后废弃，JDK 14 移除）。

#### **5. G1（Garbage-First）**

- **分代**：全堆分区（Region）
- **算法**：标记-整理 + 复制算法
- **特点**：
  - 将堆划分为多个 Region，优先回收价值高的区域。
  - 可预测停顿时间（`-XX:MaxGCPauseMillis`）。
- **优点**：平衡吞吐与延迟，避免碎片。
- **缺点**：内存占用高（Remembered Set），小堆性能较差。
- **场景**：JDK 9+ 默认收集器，适用于大堆和低延迟需求。

#### **6. ZGC（Z Garbage Collector）**

- **分代**：全堆（JDK 15+ 支持分代）
- **算法**：染色指针 + 读屏障 + 并发整理
- **特点**：
  - 最大停顿时间 < 10ms，支持 TB 级堆。
  - 基于 Region，并发标记、转移、重映射。
- **优点**：极低延迟，无碎片。
- **缺点**：高内存占用（需 64 位），JDK 11+ 支持。
- **场景**：超大堆和超低延迟（如实时系统）。

#### **7. Shenandoah**

- **分代**：全堆
- **算法**：并发复制 + 读屏障
- **特点**：与 ZGC 类似，但通过 Brooks 指针实现并发压缩。
- **优点**：低延迟，停顿时间与堆大小无关。
- **缺点**：需特定 JDK 版本（如 Red Hat 发行版）。
- **场景**：高并发、低延迟需求。





## 2.5,==重点==GC ROOT对象有哪些

> 1. gc root的定义
> 2. 那些具体对象：
>    1.  Java虚拟机栈中的对象
>    2.  静态变量引用的对象
>    3.  final 常量引用的对象，string 不可变对象
>    4.  本地方法栈

在Java虚拟机（JVM）中，**GC Root对象**是垃圾回收（Garbage Collection, GC）的起点，用于判断对象的存活状态。如果一个对象无法通过引用链从任意GC Root到达，则会被标记为可回收。以下是GC Root的主要类型及其作用：

------

### **1. 虚拟机栈中的局部变量**

- **作用**：当前正在执行的方法中的局部变量（包括参数、临时变量等）引用的对象。
- **示例**：线程方法栈帧中的对象引用，在方法执行期间不会被回收。
- **生命周期**：方法执行结束后，局部变量销毁，相关引用断开。

------

### **2. 方法区中的静态变量**

- **作用**：类的静态变量（`static`修饰）引用的对象。
- **示例**：`public static Object obj = new Object();`，`obj`指向的对象会长期存活，直到类被卸载。
- **生命周期**：与类的生命周期一致（通常较长时间）。

------

### **3. 方法区中的常量引用**

- **作用**：常量池中的引用（如字符串常量、`final`常量）。
- **示例**：`String s = "Java";`，字符串常量池中的`"Java"`会被视为GC Root。
- **生命周期**：与常量池的生命周期一致。

------

### **4. 本地方法栈中的JNI引用**

- **作用**：通过Java本地接口（JNI）调用的本地（Native）方法引用的对象。
- **示例**：在C/C++代码中通过JNI创建的对象，需通过全局引用（Global Reference）防止被回收。
- **生命周期**：依赖本地代码的显式释放。

------

### **5. Java虚拟机内部引用**

- **作用**：JVM内部系统对象，如类元数据（`Class`对象）、异常对象（如`NullPointerException`）、系统类加载器等。
- **示例**：`Object.class`对应的`Class`对象，不会被回收。
- **生命周期**：常驻内存，直到JVM关闭。

------

### **6. 被同步锁持有的对象**

- **作用**：作为`synchronized`锁的对象。
- **示例**：`synchronized(obj) { ... }`中的`obj`，在锁未释放时不会被回收。
- **生命周期**：锁释放后，若无其他引用则可能被回收。

------

### **7. 活跃线程对象**

- **作用**：正在运行的线程（`Thread`实例）及其引用的对象（如`Runnable`实现类）。
- **示例**：`Thread`对象本身和其栈中的局部变量引用的对象。
- **生命周期**：线程运行期间持续存活。

------

### **GC Root的作用机制**

- **标记阶段**：从所有GC Root出发，遍历所有可达对象，标记为存活。
- **回收阶段**：未被标记的对象（不可达对象）被回收。

------

### **示例场景**

```java
public class Example {
    private static Object staticObj = new Object(); // GC Root（静态变量）
    private final String constant = "Hello";        // GC Root（常量）

    public void method() {
        Object localObj = new Object(); // GC Root（局部变量）
        synchronized (localObj) {       // GC Root（同步锁持有对象）
            // ...
        }
    }
}
```

- `staticObj`、`constant`、`localObj`均为GC Root，其引用的对象在存活期间不会被回收。

------

### **总结**

GC Root是JVM垃圾回收的锚点，确保关键对象（如活跃线程、静态变量等）不会被错误回收。理解GC Root的类型和生命周期，有助于优化内存管理和避免内存泄漏。



## 2.6,了解哪些垃圾收集器, 说说G1和CMS的区别







## 2.7,垃圾回收有哪些算法

JVM 的垃圾回收（Garbage Collection, GC）算法是内存管理的核心，不同算法适用于不同场景和对象生命周期。以下是 JVM 中常见的垃圾回收算法及其特点：

------

### **一、基础垃圾回收算法**

1. **标记-清除（Mark-Sweep）**

   - **原理**：
     - **标记阶段**：遍历所有对象，标记存活对象（从 GC Roots 出发，通过可达性分析）。
     - **清除阶段**：回收未被标记的垃圾对象。
   - **优点**：实现简单，不移动对象。
   - **缺点**：内存碎片化，可能触发频繁的 Full GC；效率较低（需要遍历两次内存）。

2. **复制算法（Copying）**

   - **原理**：
     - 将内存分为大小相等的两块（如 `From` 和 `To`），每次只使用其中一块。
     - 将存活对象复制到另一块内存，然后清空当前块。
   - **优点**：无内存碎片，适合对象存活率低的场景（如年轻代）。
   - **缺点**：内存利用率低（需预留一半空间）；复制开销大，适合小内存区域。

3. **标记-整理（Mark-Compact）**

   - **原理**：
     - **标记阶段**：与标记-清除相同。
     - **整理阶段**：将存活对象向内存一端移动，清理边界外的空间。
   - **优点**：避免碎片化，适合老年代。
   - **缺点**：整理过程需要移动对象，效率较低。

   ==注意==

   1. 标记-清除 遍历两次内存
   2. 标记-整理 遍历两次内存
   3. 复制 ： 一次遍历内存，从gcroot 出发找打存活对象 然后进行复制

   

   | 垃圾回收器            | 年轻代算法         | 老年代算法            | 特点                       |
   | :-------------------- | :----------------- | :-------------------- | :------------------------- |
   | **Serial**            | 复制算法           | 标记-整理             | 单线程，适合客户端应用     |
   | **Parallel Scavenge** | 复制算法           | 标记-整理             | 多线程，高吞吐量           |
   | **ParNew**            | 复制算法           | 标记-清除（CMS 配合） | 多线程，配合 CMS 使用      |
   | **CMS**               | -                  | 标记-清除（并发）     | 低延迟，但内存碎片化       |
   | **G1**                | 复制算法（Region） | 标记-整理（Region）   | 分区回收，可控停顿时间     |
   | **ZGC**               | 染色指针+读屏障    | 无分代（全区域）      | 亚毫秒级停顿，支持 TB 级堆 |
   | **Shenandoah**        | 转发指针+读屏障    | 无分代（全区域）      | 低延迟，与 ZGC 类似        |

## 2.8, 复制算法

### **复制算法的核心思想**

1. **内存划分**：
   - 将可用内存分为两块大小相等的区域（如 `From` 和 `To`）。
   - 每次只使用其中一块（如 `From` 区），另一块（如 `To` 区）保持空闲。
2. **对象分配**：
   - 新对象分配在 `From` 区。
3. **垃圾回收过程**：
   - 当 `From` 区满时，触发垃圾回收。
   - **遍历存活对象**：从 GC Roots 出发，标记所有存活对象。
   - **复制存活对象**：将存活对象复制到 `To` 区。
   - **清空 `From` 区**：回收 `From` 区的所有垃圾对象。
   - **角色交换**：`From` 和 `To` 区的角色互换，`To` 区变为新的 `From` 区。

------

### **为什么复制算法不需要两次遍历？**

1. **一次遍历完成标记和复制**：
   - 在复制算法中，**标记存活对象**和**复制存活对象**是**同步完成**的。
   - 从 GC Roots 出发遍历对象图时，每遇到一个存活对象，直接将其复制到 `To` 区，同时完成标记和复制。
2. **无需清除阶段**：
   - 复制算法直接清空 `From` 区，无需像标记-清除算法那样遍历整个内存区域来回收垃圾对象。
3. **内存布局的优化**：
   - 复制算法通过将存活对象集中复制到 `To` 区，避免了内存碎片问题，同时简化了回收过程。

------

### **复制算法的优点**

1. **高效**：
   - 只需遍历存活对象一次，避免了标记-清除算法的两次遍历。
   - 适合对象存活率低的场景（如年轻代）。
2. **无内存碎片**：
   - 存活对象被连续复制到 `To` 区，内存空间紧凑。
3. **简单实现**：
   - 无需维护复杂的数据结构（如空闲列表）。

------

### **复制算法的缺点**

1. **内存利用率低**：
   - 需要预留一半内存空间作为空闲区域，实际可用内存减少。
2. **复制开销**：
   - 如果存活对象较多，复制开销较大（适合对象存活率低的场景）。
3. **不适合老年代**：
   - 老年代对象存活率高，复制算法效率低。

在 Java 虚拟机（JVM）的新生代（Young Generation）中，对象从 **伊甸区（Eden 区）** 转移到 **幸存区（Survivor 区）** 的时机与 **垃圾回收（Minor GC）** 密切相关。以下是详细的触发条件和过程：

------

### **1. 触发条件：Eden 区空间不足**

- **新对象优先分配在 Eden 区**：所有新创建的对象（除非是大对象直接进入老年代）首先在 Eden 区分配内存。
- **Eden 区满时触发 Minor GC**：当 Eden 区没有足够空间分配新对象时，JVM 会触发一次 **Minor GC**（新生代垃圾回收）。

------

### **2. 转移过程：存活对象复制到 Survivor 区**

在 Minor GC 过程中，Eden 区和 Survivor 区的存活对象会被复制到另一个 Survivor 区（遵循 **复制算法**）：

1. **标记存活对象**

   - 从 GC Roots（如线程栈、静态变量等）出发，标记 Eden 区和当前活动的 Survivor 区（From Survivor）中的存活对象。

2. **复制到 Survivor 区**

   - 将 Eden 区和 From Survivor 区的存活对象**复制到 To Survivor 区**（另一个空闲的 Survivor 区）。
   - 复制过程中，存活对象在 To Survivor 区按顺序紧密排列，**消除内存碎片**。

3. **清理 Eden 区和 From Survivor 区**

   - 直接清空 Eden 区和 From Survivor 区的所有内容（死亡对象被回收）。

4. **交换 Survivor 区角色**

   - From Survivor 和 To Survivor 的

     角色交换：

     - 原 To Survivor 变为下一次 GC 的 From Survivor。
     - 原 From Survivor 变为下一次 GC 的 To Survivor。

------

### **3. 特殊情况处理**

#### **Survivor 区空间不足**

- 如果 To Survivor 区空间不足以存放所有存活对象，会触发分配担保（Handle Promotion）：
  - 直接将这些对象**晋升到老年代**（Old Generation），避免内存溢出。

#### **对象年龄阈值**

- 每次 Minor GC 后，存活对象的**年龄（Age）**会加 1。
- 当对象年龄达到阈值（默认 `15`，可通过 `-XX:MaxTenuringThreshold` 调整）时，下次 Minor GC 会晋升到老年代。

------

### **4. 新生代内存划分（HotSpot 默认比例）**

- 新生代通常按 `Eden : Survivor : Survivor = 8:1:1` 划分（例如：总大小 10MB，则 Eden 8MB，每个 Survivor 1MB）。
- 设计目的：
  - 减少内存浪费（仅 10% 空间闲置）。
  - 适应新生代对象“朝生夕死”的特点（98% 对象活不过第一次 Minor GC）。

------

### **示例流程**

1. **初始状态**
   - Eden 区已满，From Survivor 区存有前一次 GC 的存活对象，To Survivor 区为空。
2. **触发 Minor GC**
   - 标记 Eden 和 From Survivor 的存活对象。
3. **复制到 To Survivor**
   - 存活对象被复制到 To Survivor 区（若年龄达标则晋升到老年代）。
4. **清理并交换角色**
   - 清空 Eden 和 From Survivor，交换 From 和 To 的角色。

------

### **总结**

- **何时转移**：当 Eden 区空间不足触发 Minor GC 时，存活对象从 Eden 区和 From Survivor 区复制到 To Survivor 区。
- **核心机制**：基于复制算法，避免内存碎片，高效回收短生命周期对象。
- 关键参数：
  - `-Xmn`：设置新生代大小。
  - `-XX:SurvivorRatio`：调整 Eden 与 Survivor 区的比例（例如 `-XX:SurvivorRatio=8` 表示 Eden:Survivor=8:1:1）。

通过这种方式，JVM 确保新生代的高效内存管理，适应高频创建和销毁对象的场景。



## 2.8,标记-清除算法的原理

### **1. 标记阶段（第一次遍历）**

- **目标**：确定哪些对象是存活的。
- **过程**：
  1. 从 **GC Roots**（如线程栈、静态变量等）出发，通过引用链遍历所有可达对象。
  2. 对遍历到的存活对象打上标记（例如在对象头中记录状态）。
- **关键点**：
  - 遍历的是**对象引用关系图**，而非物理内存的每个地址。
  - 存活对象可能分散在堆内存各处，遍历路径取决于对象的引用关系。

------

### **2. 清除阶段（第二次遍历）**

- **目标**：回收未被标记的垃圾对象。
- **过程**：
  1. **线性扫描整个堆内存**，检查每个内存块的标记状态。
  2. 对未标记的内存块进行回收（直接释放或加入空闲列表）。
- **关键点**：
  - 必须遍历**所有内存区域**，无论是否存储对象。
  - 需要确保所有未被标记的垃圾对象都被回收。





## 2.9,有jvm调优的经验吗



## 2.10,==重点==怎么判断一个对象能否被回收

VM 判断对象能否被回收的核心机制是 **可达性分析（Reachability Analysis）**，通过判断对象是否与 GC Roots 存在引用链来决定其存活状态。以下是具体实现细节和关键点：

------

### **1. 可达性分析算法**

- **基本原理**：从一组称为 **GC Roots** 的根对象出发，遍历所有引用链，遍历到的会被标记为存活。

  > 标记-整理（标记存活的，整理存活的），标记-清除（标记存活，第二次遍历清除要回收的）

- **GC Roots 包括**：

  - 虚拟机栈（栈帧中的局部变量表）中引用的对象（如当前执行方法中的局部变量）。
  - 方法区中类静态属性（`static` 字段）引用的对象。
  - 方法区中常量（`final` 常量）引用的对象。
  - 本地方法栈（JNI）中引用的 Native 方法对象。
  - JVM 内部系统对象（如 Class 对象、异常对象、类加载器等）。

------

### **2. 引用类型对回收的影响**

Java 对引用进行了细化，不同引用类型直接影响回收策略：

1. **强引用（Strong Reference）**
   - 最常见的引用（如 `Object obj = new Object()`）。
   - 只要强引用存在，对象**永远不会被回收**。
2. **软引用（Soft Reference）**
   - 通过 `SoftReference` 类实现。
   - 内存不足时（触发 Full GC 前），**会回收软引用对象**。
   - 适合缓存场景。
3. **弱引用（Weak Reference）**
   - 通过 `WeakReference` 类实现。
   - **下一次垃圾回收时必定被回收**，无论内存是否充足。
   - 常见于缓存或弱关联数据结构（如 `WeakHashMap`）。
4. **虚引用（Phantom Reference）**
   - 通过 `PhantomReference` 类实现。
   - 无法通过虚引用访问对象，主要用于跟踪对象被回收的状态（如堆外内存管理）。



## 2.11，Yunng GC/Full GC各种垃圾回收器，哪些情况会导致 stop-the-world





## 3. 1 JMM 

> 内存屏障是一种硬件指令 ,哪怕是 c/c++ 也需要依赖不同平台的硬件指令来实现

### Java 内存模型（JMM，Java Memory Model）

Java 内存模型（JMM）是 Java 虚拟机（JVM）规范中定义的一种**抽象概念**，用于描述线程之间如何通过内存进行交互。它主要解决的是多线程环境下的**可见性** 、**原子性** 和**有序性** 问题，确保在并发编程中程序的行为符合预期。

#### 1. **JMM 的核心概念**

JMM 定义了线程与主内存之间的关系，以及线程如何通过工作内存（Working Memory）来访问共享变量。以下是 JMM 的几个关键点：

- **主内存（Main Memory）**
  主内存是所有线程共享的内存区域，存储了所有的共享变量（如实例字段、静态字段等）。每个线程都可以从主内存中读取数据或将数据写入主内存。
- **工作内存（Working Memory）**
  每个线程都有自己的工作内存（可以理解为线程私有的缓存），线程对变量的操作必须先将变量从主内存加载到工作内存中，操作完成后可能再将结果写回主内存。
- **线程间的通信**
  线程之间的通信需要通过主内存完成：一个线程修改了共享变量的值后，其他线程只有在该值被刷新回主内存并重新加载到自己的工作内存时，才能看到最新的值。

------

#### 2. **JMM 的三大特性**

JMM 的设计目标是保证多线程环境下的以下三个特性：

##### （1）**可见性**

- 当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。
- 可见性问题通常由 CPU 缓存或编译器优化引起。例如，线程 A 修改了一个变量，但该变量可能仍然停留在 A 的工作内存中，尚未刷新到主内存，导致线程 B 无法看到最新值。
- 解决可见性问题的常见方法：
  - 使用 `volatile` 关键字：强制线程每次读取变量时都从主内存获取最新值。
  - 使用 `synchronized` 关键字：保证同一时刻只有一个线程能访问同步代码块，并且释放锁时会将变量刷新回主内存。
  - 使用 `java.util.concurrent` 包中的工具类（如 `AtomicInteger`）。

##### （2）**原子性**

- 原子性是指一个操作或者多个操作要么全部执行并且执行过程不被中断，要么完全不执行。
- 在 Java 中，基本类型的读写操作通常是原子性的（除了 `long` 和 `double` 的非 volatile 变量外）。但对于复合操作（如 `i++`），则需要额外的同步机制来保证原子性。
- 解决原子性问题的常见方法：
  - 使用 `synchronized` 关键字。
  - 使用 `java.util.concurrent.atomic` 包中的原子类（如 `AtomicInteger`、`AtomicLong`）。

##### （3）**有序性**

- 在 Java 中，为了提高性能，编译器和处理器可能会对指令进行重排序（Instruction Reordering）。这种重排序在单线程环境下不会影响程序的正确性，但在多线程环境下可能导致意外的结果。
- 解决有序性问题的常见方法：
  - 使用 `volatile` 关键字：禁止指令重排序。
  - 使用 `synchronized` 关键字：保证同步代码块内的操作按顺序执行。
  - 使用 `Lock` 接口：提供更灵活的锁机制。

------

#### 3. **JMM 的实现机制**

JMM 通过以下机制来保证上述三大特性：

##### （1）**happens-before 规则**

`happens-before` 是 JMM 的核心规则，用于描述两个操作之间的顺序关系。如果操作 A happens-before 操作 B，则 A 的结果对 B 是可见的。常见的 happens-before 规则包括：

- 程序顺序规则：同一个线程中，前面的操作 happens-before 后面的操作。
- 锁定规则：解锁操作 happens-before 后续的加锁操作。
- volatile 规则：对 volatile 变量的写操作 happens-before 后续的读操作。
- 线程启动规则：线程的启动操作 happens-before 该线程的任何操作。
- 线程终止规则：线程的所有操作 happens-before 其他线程检测到该线程已终止。
- 线程中断规则：对线程的中断操作 happens-before 被中断线程检测到中断事件。
- 对象终结规则：对象的构造完成 happens-before 其 finalize 方法的开始。

##### （2）**内存屏障（Memory Barrier）**

内存屏障是一种底层硬件指令，用于控制指令的执行顺序，**防止编译器**和**处理器对指令**进行重排序。JMM 利用内存屏障来实现 `volatile` 和 `synchronized` 的语义。

------

#### 4. **volatile 关键字的作用**

`volatile` 是 JMM 提供的一种轻量级同步机制，主要用于保证变量的**可见性** 和**有序性** ，但不保证**原子性** 。它的作用如下：

- **可见性** ：当一个线程修改了 `volatile` 变量的值，其他线程能够立即看到最新值。
- **有序性** ：禁止指令重排序，确保 `volatile` 变量的读写操作不会被重排序。

示例代码：

```java
class VolatileExample {
    private volatile boolean flag = true;

    public void stop() {
        flag = false; // 修改标志位
    }

    public void run() {
        while (flag) {
            // 执行任务
        }
        System.out.println("Thread stopped.");
    }
}
```

在这个例子中，`volatile` 保证了主线程对 `flag` 的修改能够被其他线程立即感知。

------

#### 5. **总结**

Java 内存模型（JMM）是 Java 并发编程的基础，它通过定义主内存和工作内存的关系，解决了多线程环境下的可见性、原子性和有序性问题。理解 JMM 的核心概念和实现机制，对于编写高效、正确的并发程序至关重要。

如果你有更多关于 JMM 或并发编程的问题，欢迎继续提问！
